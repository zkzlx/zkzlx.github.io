<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.4.2',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="吃饭、睡觉、写代码、周而复始">
<meta property="og:type" content="website">
<meta property="og:title" content="冰封">
<meta property="og:url" content="https:&#x2F;&#x2F;zkzlx.github.io&#x2F;index.html">
<meta property="og:site_name" content="冰封">
<meta property="og:description" content="吃饭、睡觉、写代码、周而复始">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://zkzlx.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>冰封</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta custom-logo">
      <div class="site-meta-headline">
        <a>
          <img class="custom-logo-image" src="/images/avatar2.gif" alt="冰封">
        </a>
      </div>

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">冰封</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/zkzlx/zkzlx.github.io" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zkzlx.github.io/2019/10/java/Synchronized/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="zkzlx">
      <meta itemprop="description" content="吃饭、睡觉、写代码、周而复始">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰封">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/java/Synchronized/" class="post-title-link" itemprop="url">揭秘`Synchronized`</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-28 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-28T00:00:00+08:00">2019-10-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-31 15:12:10" itemprop="dateModified" datetime="2019-10-31T15:12:10+08:00">2019-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><h4 id="基本认知"><a href="#基本认知" class="headerlink" title="基本认知"></a>基本认知</h4><ul>
<li>被用来解决数据共享访问的安全性问题最常见的应用</li>
</ul>
<h5 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h5><blockquote>
<p>不同的修饰类型，代表锁的控制粒度</p>
</blockquote>
<ul>
<li>修饰实例方法<ul>
<li>作用于当前实例加锁，进入同步代码前要获得当前实例的锁</li>
</ul>
</li>
<li>静态方法<ul>
<li>作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</li>
</ul>
</li>
<li>修饰代码块，<ul>
<li>指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
</ul>
</li>
</ul>
<h4 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h4><p>旧时代的<code>重量级锁</code>，1.6版本开始为了减少锁竞争的性能开销，引入了偏向锁、轻量级锁的概念；根据竞争的激烈程度锁状态从低到高不断升级。<br>既然是通过锁的状态来进行锁的升级，那么锁是如何存储的呢？</p>
<h5 id="锁的存储"><a href="#锁的存储" class="headerlink" title="锁的存储"></a>锁的存储</h5><ul>
<li><p>从synchronized的语法来看是基于lock这个对象的生命周期来控制锁粒度的。</p>
<blockquote>
<p>从<code>JVM</code>源码分析能得到<code>Markword</code> （<code>markOop</code>类型），<code>JVM</code>源码自己翻哈</p>
</blockquote>
</li>
<li><p>Mark word记录了对象和锁有关的信息，Mark Word在32位<code>JVM</code>的长度是<code>32bit</code>、在64位<code>JVM</code>的长度是<code>64bit</code>。<br>Mark Word里面存储的数据会随着锁标志位的变化而变化，可分为以下5种情况：</p>
<img src="/2019/10/java/Synchronized/markWord.png" class="">

</li>
</ul>
<h5 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h5><p>锁存在四种状态分别是：无锁、偏向锁、轻量级锁、重量级锁</p>
<h6 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h6><p>当访问有同步锁的代码块时，会在对象头中存储当前线程的ID，后续该线程再次访问该段同步锁代码时不需要再次加锁和释放锁，而是直接比较对象头里中的线程id。若相等则表示锁是偏向于当前线程的，就不需要再尝试获得锁了</p>
<ul>
<li><p><code>锁获取</code></p>
<ul>
<li>先获取锁对象的<code>Markword</code> ，判断是否处于可偏向状态。（<code>biased_lock</code>=1、且 <code>ThreadId</code> 为空）</li>
<li>若是可偏向状态，则通过<code>CAS</code>操作，把当前线程的ID写入到<code>Markword</code> <ul>
<li><code>CAS</code>成功，则表示已经获得了偏向锁，接着执行同步代码块</li>
<li><code>CAS</code>失败，则有其他线程已经获得了偏向锁存在锁竞争；<br>  要撤销已获得偏向锁的线程且把它持有的锁升级为轻量级锁（在全局安全点才能操作，也就是没有线程在执行字节码）</li>
</ul>
</li>
<li>若是已偏向状态，则判断<code>Markword</code> 中存储的线程ID是否与当前线程ID相等<ul>
<li>若相等，则不需要再次获得锁，可直接执行同步代码块</li>
<li>若不相等，则当前锁偏向于其他线程，需要撤销偏向锁并升级到轻量级锁</li>
</ul>
</li>
</ul>
</li>
<li><p><code>锁撤销</code></p>
<ul>
<li>本质并不是把对象恢复到无锁可偏向状态，而是在获取过程中存在竞争时是直接把被偏向的锁对象升级到被加了轻量级锁的状态。<br>那么已获得偏向锁的线程有两种情况：<ul>
<li>若已获得偏向锁的线程已退出临界区则此时会将对象头设置成无锁状态并且竞争锁的线程可以基于CAS重新偏向</li>
<li>若已获得偏向锁的线程还未退出临界区则此时会把原获得偏向锁的线程升级为轻量级锁后继续执行同步代码块<blockquote>
<p>临界区可以理解成要同步代码块的区段，进入就是开始执行同步代码块，退出就代码同步代码块执行完毕</p>
<blockquote>
<p><code>JVM</code>设置开启或关闭偏向锁：<code>UseBiasedLocking</code></p>
</blockquote>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h6><ul>
<li><p>锁升级为轻量级锁之后，对象的 <code>Markword</code> 也会进行相应的变化。过程如下：</p>
<ul>
<li>线程在自己的栈桢中创建锁记录 <code>LockRecord</code></li>
<li>将锁对象的对象头中的 <code>MarkWord</code> 复制到线程的刚刚创建的锁记录中</li>
<li>将锁记录中的 Owner 指针指向锁对象</li>
<li>将锁对象的对象头的 <code>MarkWord</code> 替换为指向锁记录的指针 </li>
</ul>
</li>
<li><p><code>锁获取-自旋锁</code></p>
<ul>
<li><p>所谓自旋就是指当有竞争锁时，这个线程会在原地循环等待(会消耗<code>cpu</code>)，而不是阻塞，直到那个<br>获得锁的线程释放锁之后，这个线程就可以马上获得锁的。所以轻量级锁适用于那些同步代码块执行的很快的场景可以缩短锁的获取时间。</p>
<p>自旋锁其实就是<code>空间换时间</code>的操作，<br>但是自旋必须有次数限制否则不断的循环反而会消耗CPU资源。 默认情况下自旋的次数是 10 次，<br>可以通过 <code>preBlockSpin</code> 来修改  </p>
</li>
</ul>
<blockquote>
<p>在 <code>JDK1.6</code> 之后，引入了自适应自旋锁，即自旋的次数是动态变化的；会根据前一次在同一个锁上自旋的时间以及锁的拥有者的状态来决定。<br>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并<br>且持有锁的线程正在运行中，那么虚拟机就会认为这次自<br>旋也是很有可能再次成功，进而它将允许自旋等待持续相<br>对更长的时间。如果对于某个锁，自旋很少成功获得过，<br>那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源 </p>
</blockquote>
</li>
<li><p><code>锁释放</code></p>
<ul>
<li><p>锁释放逻辑本质就是锁获取的逆向逻辑，通过<br><code>CAS</code> 操作把线程栈帧中的 <code>LockRecord</code> 替换回到锁对象的<br><code>MarkWord</code> 中，若成功表示没有竞争，若失败表示当前锁存在竞争，那么轻量级锁就会升级成为重量级锁  </p>
<p>​    </p>
</li>
</ul>
</li>
</ul>
<h6 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h6><p>到这个阶段就意味着线程只能被挂起阻塞来等待被唤醒了 </p>
<ul>
<li><p>在class字节码中可以看到加入同步代码块后会有<code>monitorenter</code> 和 <code>monitorexit</code>  </p>
<blockquote>
<p>可以使用以下命令查看: <code>javap -v  xxx.class</code></p>
</blockquote>
</li>
<li><p><code>monitorenter</code> 表示尝试获得一个对象监视器。 <code>monitorexit</code> 表示释放<code>monitor</code>监视器的所有权。<code>monitor</code>依赖操作系统的 <code>MutexLock</code>(互斥锁)实现的，当线程被阻塞后便进入内核态从而导致系统调度要在用户态与内核态之间来回切换，所以性能相对较低</p>
<blockquote>
<p>每一个 JAVA 对象都会与一个监视器 monitor 关联（可以理解成一把锁），当一个线程想要执行一段被<br>synchronized 修饰的同步方法或者代码块时，该线程得先获取到 synchronized 修饰的对象对应的 monitor</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>引用一张别人的锁升级流程图–非常完善</p>
</blockquote>
<img src="/2019/10/java/Synchronized/synchronize.png" class="">


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zkzlx.github.io/2019/10/java/ThreadPoolExecutor/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="zkzlx">
      <meta itemprop="description" content="吃饭、睡觉、写代码、周而复始">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰封">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/java/ThreadPoolExecutor/" class="post-title-link" itemprop="url">线程池`ThreadPoolExecutor`详解</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-13 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-13T00:00:00+08:00">2019-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-29 17:48:38" itemprop="dateModified" datetime="2019-10-29T17:48:38+08:00">2019-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="线程池ThreadPoolExecutor详解"><a href="#线程池ThreadPoolExecutor详解" class="headerlink" title="线程池ThreadPoolExecutor详解"></a>线程池<code>ThreadPoolExecutor</code>详解</h3><p>内置四种构造器,但最终重载的是下面的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit</span><br><span class="line">,BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span><br></pre></td></tr></table></figure>
<h4 id="构造函数的参数说明"><a href="#构造函数的参数说明" class="headerlink" title="构造函数的参数说明"></a>构造函数的参数说明</h4><ul>
<li><code>corePoolSize</code><ul>
<li>线程池子的核心线程数</li>
</ul>
</li>
<li><code>maximumPoolSize</code><ul>
<li>池子的最大线程数,是指最大正在运行中的数量;当核心线程和阻塞队列都满了,若此时有新的线程过来,则会创建线程</li>
</ul>
</li>
<li><code>keepAliveTime</code><ul>
<li>超过核心线程数据的多余空闲线程的最大存活时间</li>
</ul>
</li>
<li><code>unit</code><ul>
<li>时间单位</li>
</ul>
</li>
<li><code>workQueue</code><ul>
<li>线程排队等待的阻塞队列,当核心线程都满了,此时若有新的线程过来,则会在这个队列中排队</li>
</ul>
</li>
<li><code>threadFactory</code><ul>
<li>线程构建工厂,默认使用default工厂</li>
</ul>
</li>
<li><code>handler</code><ul>
<li>拒绝策略,当核心线程满了,阻塞队列也满了,运行中的线程数量也达到最大数,此时若有线程进来,则会根据该策略进行拒绝服务<ul>
<li>默认提供有四种拒绝策略:<ul>
<li><code>CallerRunsPolicy</code>由调用者执行新的线程</li>
<li><code>AbortPolicy</code> 直接拒绝并抛异常(默认策略)</li>
<li><code>DiscardPolicy</code> 直接丢弃新线程</li>
<li><code>DiscardOldestPolicy</code> 丢弃最旧的线程（最先提交而没有得到执行的任务）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>corePoolSize</code>、<code>maximumPoolSize</code>、<code>workQueue</code>三者之间的关系</p>
<blockquote>
<p>1.若无空闲线程执行该任务且当前运行中线程数少于<code>corePoolSize</code>，则直接创建新线程执行该任务。</p>
<p>2.若无空闲线程执行该任务且当前运行中线程数等于<code>corePoolSize</code>且阻塞队列未满，则将任务入队列等待，而不创建新线程</p>
<p>3.若无空闲线程执行该任务且阻塞队列已满同时池中的线程数小于<code>maximumPoolSize</code>，则创建新线程执行该任务</p>
<p>4.若无空闲线程执行该任务且阻塞队列已满同时池中的线程数等于<code>maximumPoolSize</code>，则根据构造函数中的<code>handler</code>指定的策略来拒绝新的任务</p>
</blockquote>
</blockquote>
<h4 id="ThreadPoolExecutor扩展"><a href="#ThreadPoolExecutor扩展" class="headerlink" title="ThreadPoolExecutor扩展"></a>ThreadPoolExecutor扩展</h4><p>ThreadPoolExecutor扩展主要是围绕<code>beforeExecute()</code>、<code>afterExecute()</code>和<code>terminated()</code>三个接口实现的，</p>
<ul>
<li>beforeExecute：线程池中任务运行前执行</li>
<li>afterExecute：线程池中任务运行完毕后执行</li>
<li>terminated：线程池退出后执行<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1000</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>)</span><br><span class="line">    , (runnable)-&gt; <span class="keyword">new</span> Thread(runnable, <span class="string">"threadPool"</span> + runnable.hashCode())</span><br><span class="line">    , <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"准备执行："</span> + t.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"执行完毕："</span> + t.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"线程池退出"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><h4 id="主要参数说明"><a href="#主要参数说明" class="headerlink" title="主要参数说明"></a>主要参数说明</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收新任务，并且执行缓存任务队列中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; <span class="number">29</span> ;<span class="comment">// 1010 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">// 不在接收新的任务，但是会执行缓存中的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; <span class="number">29</span> ;<span class="comment">// 0000 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">// 不接收新的任务，不执行缓存中的任务，中断正在运行的任务</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; <span class="number">29</span> ;<span class="comment">// 0010 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">// 所有任务已经终止，workCount = 0;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; <span class="number">29</span> ;<span class="comment">// 0100 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"><span class="comment">// terminated 方法调用完成</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; <span class="number">29</span> ;<span class="comment">// 0110 0000 0000 0000 0000 0000 0000 0000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存任务阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">// 线程池主锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 工作线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">// mainLock上的终止条件量，用于支持awaitTermination</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"><span class="comment">// 记录曾经创建的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">// 已经完成任务数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"><span class="comment">// 新线程创建工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="comment">// 任务拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">// 超过核心线程数据的多余空闲线程的最大存活时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">// 是否允许核心线程也使用 keepAliveTime 策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"><span class="comment">// 核心线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">// 池子的最大线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"><span class="comment">// 设置默认任务拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> AbortPolicy();</span><br></pre></td></tr></table></figure>



<h4 id="核心方法submit"><a href="#核心方法submit" class="headerlink" title="核心方法submit"></a>核心方法submit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<span class="comment">//任务包装</span></span><br><span class="line">    execute(ftask);<span class="comment">//执行任务</span></span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>newTaskFor</code>是用来包装传入的任务，注意入口方法<code>execute</code>如期而至，下面我们就一点点揭开它那神秘的面纱以观其美妙的。。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">//判断当前运行中的线程数小于核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//则直接创建一个线程并将核心线程计数加一，不是对线程进行标记是否为核心</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//若添加成功则直接返回，若失败则进入下一步</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前是否可运行且队列是否未满</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//二次校验当前是否可运行</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);<span class="comment">//若不可则调用拒绝策略</span></span><br><span class="line">        <span class="comment">//判定核心线程运行数是否为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果核心与队列均满则直接添加任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>待揭开后发现还是未能触那美好的。。。别急，继续揭开核心方法<code>addWorker(Runnable firstTask, boolean core)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:<span class="comment">//标签,break或者continue到这里</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">//外层 死循环</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//当前线程的状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">//1. 如果线程池已经已经STOP,或者TIDYING，或者TERMINATED，并且firstTask == null，并且队列并不为空的情况下，</span></span><br><span class="line">        <span class="comment">// 就直接return false</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; !(rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span> &amp;&amp; !workQueue.isEmpty()) )</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">//内层 死循环</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">//2. 当线程池中的线程数量达到上限以后，返回false</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//3. 如果线程数量能够增加，则break到retry标签，（跳过内外层两层循环），继续往下执行</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) <span class="comment">// CAS操作</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// 重新读取 ctl 的值</span></span><br><span class="line">            <span class="comment">//4. 如果线程池的状态发生了改变，就continue到retry标签，重新执行外层循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">//5. 如果是因为工作线程数量的变化导致CAS操作失败，那么继续执行内层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6. 开始添加Worker的逻辑</span></span><br><span class="line">    <span class="comment">//标记新添加的工作线程是否启动</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//标记新的线程是否添加成功</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//工作线程</span></span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;<span class="comment">//说明线程工厂成功的创建了一个线程</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();<span class="comment">//获取锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());<span class="comment">//再次检查</span></span><br><span class="line">                <span class="comment">//如果线程池状态是RUNNING 或 线程池状态是SHUTDOWN 并且fistTask==null</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// 表示线程已经被启动过了，则抛出异常</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)<span class="comment">//修改最大线程数</span></span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;<span class="comment">//标记任务添加成功</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;<span class="comment">//如果成功添加任务，启动任务</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//最后判断启动任务如果失败，就把任务从工作集中移除，减小最大线程数largestPoolSize,并试着终止线程池</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;<span class="comment">//返回任务是否成功启动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续分析<code>Worker</code>中的<code>runWorker</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">//允许中断</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 从队列中取出任务可能会导致阻塞。</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;<span class="comment">//如果task不为null或者从队列中取出的任务不为null</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">//2. 线程中断，下面有详细说明</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) </span><br><span class="line">                 &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123; task.run(); <span class="comment">//3. 执行任务</span></span><br><span class="line">                &#125;<span class="keyword">catch</span> (RuntimeException x) &#123; thrown = x; <span class="keyword">throw</span> x; </span><br><span class="line">                &#125;<span class="keyword">catch</span> (Error x) &#123; thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125;<span class="keyword">catch</span> (Throwable x) &#123; thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//如果异常终止，则把当前任务从工作集中移除，试着结束线程池，添加一个新线程等等</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程中断<code>wt</code>；</p>
<ul>
<li>如果线程池处于<code>STOP</code>,<code>TIDYING</code>,<code>TERMINATED</code>状态并且<code>wt</code>没有被中断，则中断 <code>wr</code> 。</li>
<li>如果当前线程被中断了并且线程池处于<code>STOP</code>,<code>TIDYING</code>,<code>TERMINATED</code>状态并且<code>wt</code>没有被中断，则中断 <code>wr</code> </li>
</ul>
<p><code>getTask()</code>从队列得到一个task</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行阻塞或定时等待任务，具体取决于当前配置设置，或者当前worker由于以下原因必须停止的时候返回null；</span></span><br><span class="line"><span class="comment"> * 1. worker的数量大于maximumPoolSize </span></span><br><span class="line"><span class="comment"> * 2. 线程池停止了（STOP）</span></span><br><span class="line"><span class="comment"> * 3. 线程池 shutdown 了并且任务队列empty</span></span><br><span class="line"><span class="comment"> * 4. worker在等待任务的时候超时（非核心线程池超过存活时间，或者核心线程池超过存活时间）， </span></span><br><span class="line"><span class="comment"> *   超过存活时间的worker会终止，如果任务队列不为空，则当前线程不是线程池中最后一个线程</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回一个任务；或者当 worker必须退出的时候返回null，在这种情况下，workerCount 会减少。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// 在必要的条件下检查任务队列是否为empty</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">//减少线程池中线程数量，返回null</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取任务并返回，如果是定时等待任务，则使用poll方法，否则使用take方法</span></span><br><span class="line">            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS):workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zkzlx.github.io/2019/10/java/Thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="zkzlx">
      <meta itemprop="description" content="吃饭、睡觉、写代码、周而复始">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰封">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/java/Thread/" class="post-title-link" itemprop="url">线程你了解有多少？</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-12 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-12T00:00:00+08:00">2019-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-31 15:12:10" itemprop="dateModified" datetime="2019-10-31T15:12:10+08:00">2019-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="线程的出生"><a href="#线程的出生" class="headerlink" title="线程的出生"></a>线程的出生</h3><p>众所周知，计算机可以<code>“同时”</code>运行多个进程来执行不同的任务(操作系统通过CPU时间片不断切换执行从而达到宏观上的同时运行。单核CPU在任意一个CPU时间片只会有一个进程在执行)，那为什么还需要发明个线程呢？</p>
<ul>
<li>在多核 CPU 中，利用多线程可以实现真正意义上的并行执行</li>
<li>在一个应用进程中也会存在多个同时执行的任务，若其中任意任务被阻塞，按原先的方式则会导致其他任务也会被阻塞。 通过对不同任务创建不同的线程去处理，可以提升程序处理的效率</li>
<li>线程可以认为是轻量级的进程，所以线程的创建、销毁比进程的代价更小</li>
</ul>
<h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><p>Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。<br>启动线程的唯一方法就是通过 Thread 类的 start()实例方法。<br>start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现Runnable-Callable"><a href="#实现Runnable-Callable" class="headerlink" title="实现Runnable/Callable"></a>实现Runnable/Callable</h4><p>如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyThread.run()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h4><p>线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。<br>有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。<br>执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 创建多个有返回值的任务</span></span><br><span class="line">List&lt;Future&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    Callable&lt;Integer&gt; c = <span class="keyword">new</span> MyCallable(i);</span><br><span class="line">    <span class="comment">// 执行任务并获取 Future 对象</span></span><br><span class="line">    Future f = pool.submit(c);</span><br><span class="line">    list.add(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line"><span class="comment">// 获取所有并发任务的运行结果</span></span><br><span class="line"><span class="keyword">for</span> (Future f : list) &#123;</span><br><span class="line">    <span class="comment">// 从 Future 对象上获取任务的返回值，并输出到控制台</span></span><br><span class="line">    System.out.println(<span class="string">"res： "</span> + f.get().toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.........</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span><span class="params">(<span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.idx = idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>线程既然能够创建，那么也能被销毁，所以线程是有生命周期的。<br>线程一共有 6 种状态（NEW、 RUNNABLE、 BLOCKED、WAITING、 TIME_WAITING、 TERMINATED）</p>
<ul>
<li><code>NEW</code>-初始状态 <ul>
<li>线程被构建此时还未调用<code>start</code>方法</li>
</ul>
</li>
<li><code>RUNNABLED</code>-运行状态 <ul>
<li>即操作系统中的<code>就绪</code>和<code>运行</code>两种状态</li>
</ul>
</li>
<li><code>BLOCKED</code>-阻塞状态<ul>
<li>线程因为某种原因放弃了CPU使用权进入等待状态，阻塞也分为几种情况<ul>
<li>等待阻塞<ul>
<li>运行的线程执行<code>wait</code>方法， jvm会把当前线程放入到等待队列</li>
</ul>
</li>
<li>同步阻塞 <ul>
<li>运行的线程在获取对象的同步锁时，若该锁被占用了，则jvm会把当前线程放入到锁池中</li>
</ul>
</li>
<li>其他阻塞 <ul>
<li>运行的线程执行<code>Thread.sleep</code>/<code>join</code>方法或者有I/O请求时，jvm会把当前线程设置为阻塞状态，当 sleep结束/join线程终止/io处理完毕则线程进入<code>RUNNABLED</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>TIME_WAITING</code>-超时等待状态<ul>
<li>超时以后自动返回</li>
</ul>
</li>
<li><code>TERMINATED</code>-终止状态<ul>
<li>表示当前线程执行完毕</li>
</ul>
</li>
</ul>
<blockquote>
<p>线程的生命周期图例</p>
</blockquote>
<img src="/2019/10/java/Thread/thread-state.png" class="">





      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zkzlx.github.io/2019/10/java/HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="zkzlx">
      <meta itemprop="description" content="吃饭、睡觉、写代码、周而复始">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰封">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/java/HashMap/" class="post-title-link" itemprop="url">HashMap源码分析</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-11 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-11T00:00:00+08:00">2019-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-29 17:48:21" itemprop="dateModified" datetime="2019-10-29T17:48:21+08:00">2019-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a><code>HashMap</code>源码分析</h3><h4 id="1、实现原理概括"><a href="#1、实现原理概括" class="headerlink" title="1、实现原理概括"></a>1、实现原理概括</h4><ul>
<li><p><code>HashMap</code>是一个关联数组、哈希表，它是线程不安全的，允许key为null,value为null。遍历时无序</p>
</li>
<li><p>使用拉链法实现哈希表，结合了数组与链表的特点</p>
<ul>
<li>数组的特点是空间连续（大小固定）、寻址迅速，但是插入和删除时需要移动元素，所以查询快，增加删除慢</li>
<li>链表可动态增加或减少空间以适应新增和删除元素，但查找时只能顺着一个个节点查找，所以增加删除快，查找慢</li>
</ul>
</li>
<li><p>其底层数据结构是数组称之为哈希桶，每个桶里面放的是链表，链表中的每个节点，就是哈希表中的每个元素；在JDK8中，当链表长度达到8，会转化成红黑树，以提升它的查询、插入效率</p>
<ul>
<li>哈希桶的底层数据结构是数组（数组中每个元素都是链表），所以就会面临着扩容问题</li>
<li>当容量达到threshold域值时，就会触发扩容。扩容前后，哈希桶的长度一定会是2的次方。在根据key的hash值寻找对应的哈希桶时，可以用位运算替代取余操作，更加高效。</li>
<li>扩容时，会new个新的Node数组作为哈希桶，然后将原哈希表中的所有数据(Node节点)移动到新的哈希桶中，即对原哈希表中所有的数据重新做了个put操作，所以性能消耗很大；在哈希表的容量越大时，性能消耗越明显。</li>
<li>如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。</li>
<li>扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即low位， 或者扩容后的下标，即high位。 high位= low位+原哈希桶容量。</li>
</ul>
</li>
<li><p>而key的hash值，并不仅仅只是key对象的<code>hashCode()</code>方法的返回值，还会经过扰动函数的扰动，以使hash值更加均衡。</p>
<ul>
<li>扰动函数就是为了解决hash碰撞的。它会综合hash值高位和低位的特征，并存放在低位，因此在与运算时，相当于高低位一起参与了运算，以减少hash碰撞的概率。（在JDK8之前，扰动函数会扰动四次，JDK8简化了这个操作）</li>
</ul>
</li>
</ul>
<h4 id="2、代码分析"><a href="#2、代码分析" class="headerlink" title="2、代码分析"></a>2、代码分析</h4><h5 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h5><ul>
<li><code>HashMap</code>继承自<code>AbstractMap</code>，实现了Map接口，Map接口定义了所有Map子类必须实现的方法。</li>
<li><code>AbstractMap</code>也实现了Map接口，并且提供了两个实现Entry的内部类：<code>SimpleEntry</code>和<code>SimpleImmutableEntry</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">//省略....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 默认的初始容量，必须是2的幂 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">/** 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">/** 默认装载因子，默认值为0.75，如果实际元素所占容量占分配容量的75%时就要扩容了 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">/** 当链表中元素个数超过这个值时，将链表转换为红黑树 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">/** 树的链表还原阈值，当扩容时，桶中元素个数小于这个值，就会把树形的桶元素还原（切分）为链表结构 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="comment">/** 最小树形化的容量，当哈希表总容量大于该值时，链表才会树形化；避免进行扩容、树形化选择的冲突，不能小于 4 * TREEIFY_THRESHOLD */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">/** 存储数据的Entry数组，长度是2的幂 */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">/** 缓存entrySet()，用于keySet()和values() */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="comment">/** map中保存的键值对的数据量 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">/** map结构被改变的次数 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="comment">/** 需要调整大小的极限值（容量*装载因子） */</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">/** 装载因子 */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure>

<h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><ul>
<li>链表节点Node：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 根据给定的初始容量和装载因子创建一个空的HashMap */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 根据给定的初始容量并使用默认的装载因子创建一个空的HashMap */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 使用默认的容量及装载因子构造一个空的HashMap */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 通过传入的map及默认的装载因子创建一个HashMap */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个方法 <code>putMapEntries(Map m,boolean evict)</code> 涉及到其中三个重要方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">//重新计算新的阈值</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="comment">//校正阈值不会超过最大值</span></span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ? (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">//若新的阈值大于当前阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                <span class="comment">//则返回一个满足2的幂次方且大于新阈值的阈值</span></span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前数据表不为空 且新的容量大于当前阈值，则必定扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">//遍历新的map将元素依次put到当前表中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重新计算新的阈值<code>tableSizeFor(int cap)</code>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//经过下面的 或 和位移 运算， n最终各位都是1</span></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">//判断n是否越界，返回 2的n次方作为 table 的阈值</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>扩容方法<code>resize()</code>：<br>主要步骤：</p>
<ul>
<li>如果到达最大容量，那么返回当前的桶，并不再进行扩容操作，否则的话扩容为原来的两倍，返回扩容后的桶；</li>
<li>根据扩容后的桶，修改其他的成员变量的属性值；</li>
<li>根据新的容量创建新的扩建后的桶，并更新桶的引用；</li>
<li>如果原来的桶里面有元素就需要进行元素的转移；</li>
<li>在进行元素转移的时候需要考虑到元素碰撞和转红黑树操作；在发生碰撞的时候，将新加入的元素添加到末尾；</li>
<li>在扩容的过程中，按次从原来的桶中取出链表头节点，并对该链表上的所有元素重新计算hash值进行分配；</li>
<li>在元素复制的时候需要同时对低位和高位进行操作。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//oldTab 为当前表的哈希桶</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//当前哈希桶的容量 length</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//将当前的阈值缓存下来</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">//初始化新的容量和阈值为0</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果当前容量大于0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前容量已经到达上限</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//则设置阈值是2的31次方-1</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">//同时返回当前的哈希桶，不再扩容</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则新的容量为旧的容量的两倍，如果旧的容量大于等于默认初始容量16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//新的阈值也等于旧的阈值的两倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">//那么新表的容量就等于旧的阈值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">//如果当前表是空的，而且也没有阈值。代表是初始化时没有任何容量/阈值参数的情况</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">//新的阈值为 12 = 16 * 0.75</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若新的阈值为0 ，则用新的容量和新的加载因子重新计算新的阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">//阈值越界修复</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY </span><br><span class="line">                  ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将新的阈值赋值给当前的阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//根据新的容量 构建新的哈希桶</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//更新哈希桶引用</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//若就的哈希桶不为空则将其所有节点转移到新的哈希桶中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;<span class="comment">//遍历老的哈希桶</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//如果当前桶中有元素,则将链表赋值给e</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;<span class="comment">//将原哈希桶置空以便GC</span></span><br><span class="line">                <span class="comment">//如果当前链表中就一个元素，（没有发生哈希碰撞），直接将这个元素放置在新的哈希桶里</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//位运算：是用哈希值 与 桶的长度-1,由于桶的长度是2的n次方，相当于一个模运算。</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果发生过哈希碰撞 ,而且是节点数超过8个，转化成了红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//扩容是容量翻倍后原链表上的每个节点可能在low位(原来的下标)或high位(扩容后的下标)</span></span><br><span class="line">                    <span class="comment">//high位=low位+原哈希桶容量</span></span><br><span class="line">                    <span class="comment">//低位链表的头结点、尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//高位链表的头节点、尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;<span class="comment">//临时节点 存放e的下一个节点</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//位运算：用哈希值与旧的容量相与后判断是否为0，若为0应存放在低位，否则存放在高位</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//给头尾的指针赋值</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//高位的内部处理逻辑与低位相同</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//将低位链表存放在原index处</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将高位链表存放在新index处</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h5><h6 id="tableSizeFor方法"><a href="#tableSizeFor方法" class="headerlink" title="tableSizeFor方法"></a><code>tableSizeFor</code>方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新的阈值计算</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//经过下面的 或 和位移 运算， n最终各位都是1</span></span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">//判断n是否越界，返回 2的n次方作为 table 的阈值</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="resize方法："><a href="#resize方法：" class="headerlink" title="resize方法："></a>resize方法：</h6><ul>
<li>如果到达最大容量，那么返回当前的桶，并不再进行扩容操作，否则的话扩容为原来的两倍，返回扩容后的桶；</li>
<li>根据扩容后的桶，修改其他的成员变量的属性值；</li>
<li>根据新的容量创建新的扩建后的桶，并更新桶的引用；</li>
<li>如果原来的桶里面有元素就需要进行元素的转移；</li>
<li>在进行元素转移的时候需要考虑到元素碰撞和转红黑树操作；在发生碰撞的时候，将新加入的元素添加到末尾；</li>
<li>在扩容的过程中，按次从原来的桶中取出链表头节点，并对该链表上的所有元素重新计算hash值进行分配；</li>
<li>在元素复制的时候需要同时对低位和高位进行操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//oldTab 为当前表的哈希桶</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//当前哈希桶的容量 length</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//将当前的阈值缓存下来</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">//初始化新的容量和阈值为0</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果当前容量大于0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前容量已经到达上限</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//则设置阈值是2的31次方-1</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">//同时返回当前的哈希桶，不再扩容</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则新的容量为旧的容量的两倍，如果旧的容量大于等于默认初始容量16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//新的阈值也等于旧的阈值的两倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">//那么新表的容量就等于旧的阈值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">//如果当前表是空的，而且也没有阈值。代表是初始化时没有任何容量/阈值参数的情况</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">//新的阈值为 12 = 16 * 0.75</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//若新的阈值为0 ，则用新的容量和新的加载因子重新计算新的阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        <span class="comment">//阈值越界修复</span></span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY </span><br><span class="line">                  ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将新的阈值赋值给当前的阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//根据新的容量 构建新的哈希桶</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    <span class="comment">//更新哈希桶引用</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//若就的哈希桶不为空则将其所有节点转移到新的哈希桶中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;<span class="comment">//遍历老的哈希桶</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//如果当前桶中有元素,则将链表赋值给e</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;<span class="comment">//将原哈希桶置空以便GC</span></span><br><span class="line">                <span class="comment">//如果当前链表中就一个元素，（没有发生哈希碰撞），直接将这个元素放置在新的哈希桶里</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//位运算：是用哈希值 与 桶的长度-1,由于桶的长度是2的n次方，相当于一个模运算。</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果发生过哈希碰撞 ,而且是节点数超过8个，转化成了红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">//扩容是容量翻倍后原链表上的每个节点可能在low位(原来的下标)或high位(扩容后的下标)</span></span><br><span class="line">                    <span class="comment">//high位=low位+原哈希桶容量</span></span><br><span class="line">                    <span class="comment">//低位链表的头结点、尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//高位链表的头节点、尾节点</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;<span class="comment">//临时节点 存放e的下一个节点</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">//位运算：用哈希值与旧的容量相与后判断是否为0，若为0应存放在低位，否则存放在高位</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//给头尾的指针赋值</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//高位的内部处理逻辑与低位相同</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//将低位链表存放在原index处</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将高位链表存放在新index处</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h6><ul>
<li>其内部调用的是<code>putVal</code>方法<ul>
<li>需要判断是否出现哈希冲突问题：</li>
<li>其中如果哈希值相等，key也相等，则是覆盖value操作；如果不是覆盖操作，则插入一个普通链表节点；</li>
<li>遍历到尾部，追加新节点到尾部；</li>
<li>在元素添加的过程中需要随时检查是否需要进行转换成红黑树的操作；</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,  <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tab存放当前的哈希桶，p用作临时链表节点 </span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果当前哈希表是空的，代表是初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;<span class="comment">//直接扩容并将扩容后的长度赋值给n</span></span><br><span class="line">    <span class="comment">//如果当前index的节点是空的，表示没有发生哈希碰撞。直接构建一个新节点Node，挂载在index处即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//否则 发生了哈希冲突。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果哈希值相等，key也相等，则是覆盖value操作</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;<span class="comment">//将当前节点引用赋值给e</span></span><br><span class="line">        <span class="comment">//判断是否为红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//不是覆盖操作，则插入一个普通链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">////遍历到尾部，追加新节点到尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//如果追加节点后，链表数量&gt;=8，则转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果找到了要覆盖的节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果e不是null，说明有需要覆盖的节点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;<span class="comment">//则覆盖节点值，并返回原oldValue</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);<span class="comment">//这是一个空实现的函数，用作LinkedHashMap重写使用</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果执行到了这里，说明插入了一个新的节点，所以会修改modCount，以及返回null。</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)<span class="comment">//更新size，并判断是否需要扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//这是一个空实现的函数，用作LinkedHashMap重写使用</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先调用了hash(int h)方法获取了一个hash值。 “扰动函数”，这个方法的主要作用是防止质量较差的哈希函数带来过多的冲突（碰撞）问题。Java中int值占4个字节，即32位。根据这32位值进行移位、异或运算得到一个值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只做一次16位右位移异或混合：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h=key.hashCode())^(h&gt;&gt;&gt;<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>“&lt;&lt;” 左移：右边空出的位上补0，左边的位将从字头挤掉，左移一位其值相当于乘2。</p>
<p>“&gt;&gt;”右移：右边的位被挤掉，右移一位其值相当于除以2。对于左边移出的空位，如果是正数则空位补0，若为负数，可能补0或补1，这取决于所用的计算机系统。</p>
<p>“&gt;&gt;&gt;”无符号右移，右边的位被挤掉，对于左边移出的空位一概补上0。</p>
</blockquote>
<p><strong>HashMap 在这块的处理就很巧妙</strong>：</p>
<ul>
<li>取得 hashCode，该方法是native方法，根据内存地址算出来的int值</li>
<li>将取得的哈希值无符号右移16位，高位补0。并与前面第一步获得的hash码进行按位异或^ 运算。<blockquote>
<p>这样做有什么用呢？</p>
<p>为了降低哈希码的冲突。<code>hashCode</code>右移16位，正好是32bit的一半，与自己本身做异或操作（相同为0，不同为1）<br>混合原始哈希码的高位和低位并且混合后的低位也有高位的部分特征，这样高低位都参与到Hash的计算中，加大低位的随机性。</p>
<p>其实很多哈希算法，为了使元素分布均匀，都是用的取模运算，用一个值去模上总长度，即 n%hash。但在计算机中 &amp; 的效率比 % 高很多，那么如何将 % 转换为 &amp; 运算呢？在HashMap 中，是用的 (n - 1) &amp; hash 进行运算的，那么这是为什么呢？</p>
</blockquote>
</li>
<li><em>当 length = 2n 时，X % length = X &amp; (length - 1)*</em></li>
<li>长度为2的n次幂时，模运算 % 可以变换为按位与 &amp; 运算</li>
<li>一定要是2n次方，才满足上面的公式，否则就是错误的</li>
</ul>
<p><code>key.hashCode()</code>返回一个int类型的散列值。32位带符号的int表值范围从-2147483648到2147483648。只要hash函数松散的话，一般是很难发生碰撞的，但还是不能直接拿来用，需要对数组的长度取模运算<code>(n - 1) &amp; hash</code>得到余数才是索引值</p>
<p><code>HashMap</code>之所以不能保持元素的顺序有以下几点原因：</p>
<ul>
<li>插入元素的时候对元素进行哈希处理，不同元素分配到table的不同位置</li>
<li>容量拓展的时候又进行了hash处理</li>
<li>复制原表内容的时候链表被倒置其中，</li>
</ul>
<blockquote>
<p>  <code>(n-1)&amp;hash</code> 数组长度-1 和 hash 的与运算就是取模运算，这里减1是为了数组越界的问题</p>
</blockquote>
<h6 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//传入扰动后的哈希值 和 key 找到目标节点Node</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过扰动的hash后，调用<code>getNode</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找，找到返回节点，否则返回null</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//同样采用长度减一后和hash与运算得到数组的索引</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 总是会比较第一个，需要同时判断hash和值相同</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp;  ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//比较hash值的同时需要比较key的值是否相同</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zkzlx.github.io/2019/10/java/List/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="zkzlx">
      <meta itemprop="description" content="吃饭、睡觉、写代码、周而复始">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰封">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/java/List/" class="post-title-link" itemprop="url">ArrayList与LinkedList</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-10 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-10T00:00:00+08:00">2019-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-29 17:48:17" itemprop="dateModified" datetime="2019-10-29T17:48:17+08:00">2019-10-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><strong>ArrayList适合随机的查找与遍历,数据的插入和删除相对来说较低</strong></p>
<ul>
<li>内部基于数组实现</li>
<li>可对元素进行快速随机访问</li>
<li>每个元素之间不能由间隔,即数组的空间是连续的</li>
<li>当需要扩容时需要将原数组数据复制到新的存储空间<ul>
<li>若在中间插入元素时,需要对数组进行复制,移动操作,代价高</li>
</ul>
</li>
</ul>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><strong>LinkedList的插入删除元素相对来说较高,随机查找效率低下</strong></p>
<ul>
<li>内部基于链表实现</li>
<li>可对头部和尾部快速操作</li>
<li>每个元素之间可能有间隔,即链表的空间是不连续的,位置是由每个元素自己维护的</li>
</ul>
<blockquote>
<p><code>用代码实验下来,总体来说ArrayList的效率总体高与LinkedList,这个实验结论与我们众所周知的概念是有很大的出入,我已经迷失了
希望以后有更加准确的结论吧</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> extra = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Set&lt;Integer&gt; randomList = <span class="keyword">new</span> HashSet&lt;&gt;(extra);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; extra; i++) &#123;</span><br><span class="line">            randomList.add(random.nextInt(count));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里的一个测试颠覆了我对list的认知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//数组集合</span></span><br><span class="line">        List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//链表集合</span></span><br><span class="line">        List&lt;String&gt; linkList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        insert(arrayList);</span><br><span class="line">        insert(linkList);</span><br><span class="line">        System.out.println();</span><br><span class="line">        insert4Half(arrayList);</span><br><span class="line">        insert4Half(linkList);</span><br><span class="line">        System.out.println();</span><br><span class="line">        random(arrayList);</span><br><span class="line">        random(linkList);</span><br><span class="line">        System.out.println();</span><br><span class="line">        randomInsert(arrayList);</span><br><span class="line">        randomInsert(linkList);</span><br><span class="line">        System.out.println();</span><br><span class="line">        randomRemove(arrayList);</span><br><span class="line">        randomRemove(linkList);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            list.add(<span class="string">""</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> elapsed = System.currentTimeMillis() - start;</span><br><span class="line">        String prefix = list.getClass().getSimpleName();</span><br><span class="line">        System.out.print(<span class="string">" &lt;---&gt; "</span> + String.join(<span class="string">""</span>, prefix, <span class="string">"顺序插入耗时ms:"</span>, String.valueOf(elapsed)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert4Half</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; extra; i++) &#123;</span><br><span class="line">            list.add(list.size() / <span class="number">2</span>, <span class="string">"bbb"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> elapsed = System.currentTimeMillis() - start;</span><br><span class="line">        String prefix = list.getClass().getSimpleName();</span><br><span class="line">        System.out.print(<span class="string">" &lt;---&gt; "</span> + String.join(<span class="string">""</span>, prefix, <span class="string">"中间插入耗时ms:"</span>, String.valueOf(elapsed)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterate</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> elapsed = System.currentTimeMillis() - start;</span><br><span class="line">        String prefix = list.getClass().getSimpleName();</span><br><span class="line">        System.out.print(<span class="string">" &lt;---&gt; "</span> + String.join(<span class="string">""</span>, prefix, <span class="string">"顺序遍历耗时ms:"</span>, String.valueOf(elapsed)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">random</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(Integer i : randomList) &#123;</span><br><span class="line">            list.get(i.intValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> elapsed = System.currentTimeMillis() - start;</span><br><span class="line">        String prefix = list.getClass().getSimpleName();</span><br><span class="line">        System.out.print(<span class="string">" &lt;---&gt; "</span> + String.join(<span class="string">""</span>, prefix, <span class="string">"随机访问耗时ms:"</span>, String.valueOf(elapsed)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randomInsert</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(Integer i : randomList) &#123;</span><br><span class="line">            list.add(i.intValue(), <span class="string">"aa"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> elapsed = System.currentTimeMillis() - start;</span><br><span class="line">        String prefix = list.getClass().getSimpleName();</span><br><span class="line">        System.out.print(<span class="string">" &lt;---&gt; "</span> + String.join(<span class="string">""</span>, prefix, <span class="string">"随机插入耗时ms:"</span>, String.valueOf(elapsed)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randomRemove</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span>(Integer i : randomList) &#123;</span><br><span class="line">            list.remove(i.intValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> elapsed = System.currentTimeMillis() - start;</span><br><span class="line">        String prefix = list.getClass().getSimpleName();</span><br><span class="line">        System.out.print(<span class="string">" &lt;---&gt; "</span> + String.join(<span class="string">""</span>, prefix, <span class="string">"随机删除耗时ms:"</span>, String.valueOf(elapsed)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zkzlx.github.io/2019/10/java/classLoader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="zkzlx">
      <meta itemprop="description" content="吃饭、睡觉、写代码、周而复始">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰封">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/java/classLoader/" class="post-title-link" itemprop="url">classLoader</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-09T00:00:00+08:00">2019-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-31 15:11:03" itemprop="dateModified" datetime="2019-10-31T15:11:03+08:00">2019-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Java类加载机制"><a href="#Java类加载机制" class="headerlink" title="Java类加载机制"></a>Java类加载机制</h2><h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>共有五个过程:</p>
<img src="/2019/10/java/classLoader/classLoader.png" class="">

<h4 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载-Loading"></a>加载-Loading</h4><p>加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对<br>象， 作为<strong>方法区</strong>这个类的各种数据的入口。</p>
<blockquote>
<p>  这里不一定要从 Class 文件获取，这里既<br>  可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），<br>  也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。 </p>
</blockquote>
<h4 id="验证-Verification"><a href="#验证-Verification" class="headerlink" title="验证-Verification"></a>验证-Verification</h4><p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并<br>且不会危害虚拟机自身的安全。 </p>
<h4 id="准备-Preparation"><a href="#准备-Preparation" class="headerlink" title="准备-Preparation"></a>准备-Preparation</h4><p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使<br>用的内存空间。</p>
<p>注意这里所说的初始值概念，比如一个类变量定义为： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure>

<p>实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是<br>程序被编译后， 存放于类构造器<client>方法之中。</p>
<p>但是注意如果声明为： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure>

<p>在编译阶段会为 v 生成 <code>ConstantValue</code> 属性，在准备阶段jvm会根据 <code>ConstantValue</code> 属性将 v<br>赋值为 8080。 </p>
<h4 id="解析-Resolution"><a href="#解析-Resolution" class="headerlink" title="解析-Resolution"></a>解析-Resolution</h4><p>解析阶段是指虚拟机将常量池中的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程。符号引用就是 class 文件中<br>的： </p>
<ol>
<li>CONSTANT_Class_info</li>
<li>CONSTANT_Field_info</li>
<li>CONSTANT_Method_info<br>等类型的常量。 </li>
</ol>
<h5 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h5><p>符号引用与jvm实现的布局无关， 引用的目标并不一定要已经加载到内存中。</p>
<p>各种jvm实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在jvm规范的 Class 文件格式中 </p>
<h5 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h5><p>直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有<br>了直接引用，那引用的目标必定已经在内存中存在 </p>
<h4 id="初始化-Initialization"><a href="#初始化-Initialization" class="headerlink" title="初始化-Initialization"></a>初始化-Initialization</h4><p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载<br>器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 初始化阶段是执行类构造器<client>方法的过程。</p>
<h5 id="类构造器-lt-client-gt"><a href="#类构造器-lt-client-gt" class="headerlink" title="类构造器&lt;client&gt;"></a>类构造器<code>&lt;client&gt;</code></h5><p> <client>方法是由编译器自动收集类中的类变<br>量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子<client>方法执行之前，父类<br>的<client>方法已经执行完毕， 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译<br>器可以不为这个类生成<client>()方法。 </p>
<p>注意以下几种情况不会执行类初始化：</p>
<ol>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li>
<li>定义对象数组，不会触发该类的初始化。</li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触<br>发定义常量所在的类。</li>
<li>通过类名获取 Class 对象，不会触发类的初始化。</li>
<li>通过 <code>Class.forName</code> 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初<br>始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li>
<li>通过 <code>ClassLoader</code> 默认的 <code>loadClass</code> 方法，也不会触发初始化动作。 </li>
</ol>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>JVM 通过双亲委派模型进行类的加载， 当然我们也可以通过继承 <code>java.lang.ClassLoader</code><br>实现自定义的类加载器。 </p>
<img src="/2019/10/java/classLoader/loader.png" class="">

<h4 id="启动类加载器-Bootstrap-ClassLoader"><a href="#启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="启动类加载器(Bootstrap ClassLoader)"></a>启动类加载器(Bootstrap ClassLoader)</h4><p>负责加载 JAVA_HOME\lib 目录中的， 或通过-Xbootclasspath 参数指定路径中的， 且被<br>虚拟机认可（按文件名识别， 如 rt.jar） 的类。 </p>
<h4 id="扩展类加载器-Extension-ClassLoader"><a href="#扩展类加载器-Extension-ClassLoader" class="headerlink" title="扩展类加载器(Extension ClassLoader)"></a>扩展类加载器(Extension ClassLoader)</h4><p>负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类<br>库。 </p>
<h4 id="应用程序类加载器-Application-ClassLoader"><a href="#应用程序类加载器-Application-ClassLoader" class="headerlink" title="应用程序类加载器(Application ClassLoader)"></a>应用程序类加载器(Application ClassLoader)</h4><p>负责加载用户路径（classpath）上的类库。 </p>
<h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>当一个类收到了类加载请求，首先不会尝试自己去加载这个类，而是把这个请求委派给父<br>类去完成，每个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，<br>只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的<br>Class）， 子类加载器才会尝试自己去加载。</p>
<p>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 <code>java.lang.Object</code>，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object 对象 </p>
<img src="/2019/10/java/classLoader/parentsDelegate.png" class="">




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zkzlx.github.io/2019/10/java/jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/custom-logo.jpg">
      <meta itemprop="name" content="zkzlx">
      <meta itemprop="description" content="吃饭、睡觉、写代码、周而复始">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="冰封">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/java/jvm/" class="post-title-link" itemprop="url">JAVA虚拟机</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-08 00:00:00" itemprop="dateCreated datePublished" datetime="2019-10-08T00:00:00+08:00">2019-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-31 15:10:07" itemprop="dateModified" datetime="2019-10-31T15:10:07+08:00">2019-10-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="JAVA虚拟机"><a href="#JAVA虚拟机" class="headerlink" title="JAVA虚拟机"></a>JAVA虚拟机</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>是可运行java代码的虚拟机,它包括一套字节指令集,一组寄存器,一个垃圾回收,一个方法存储域,一个栈和一个堆.</li>
<li>它是一种软件,运行在操作系统中,与硬件没有直接交互</li>
</ul>
<h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><img src="/2019/10/java/jvm/jvm-1.png" class="">

<ul>
<li>Java源文件通过编译器生成对应的.class字节码文件,而字节码文件通过JVM中加载器和解释器生成对应机器上的机器码,从而通过系统被执行</li>
<li>大致过程如下:<ul>
<li>Java源文件–-&gt;编译器–&gt;字节码文件–-&gt;JVM–&gt;机器码</li>
</ul>
</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h3><p>​    可大致分为以下3大区域</p>
<ul>
<li>线程私有区域<ul>
<li>本地方法区<ul>
<li>调用native方法</li>
<li>会发生异常<ul>
<li>若线程请求的栈升读大于JVM所允许的深度异常抛出StackOverflowError</li>
<li>允许动态扩展,若无法申请到足够内存异常抛出OutOfMemoryError</li>
</ul>
</li>
</ul>
</li>
<li>栈<ul>
<li>和线程的生命周期相同</li>
<li>在一个线程总每调用一个方法会创建一个栈帧,每个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程<ul>
<li>栈帧的结构如下<ul>
<li>局部变量表  |  操作数栈</li>
<li>动态链接      |  方法出口</li>
</ul>
</li>
</ul>
</li>
<li>会发生异常<ul>
<li>若线程请求的栈升读大于JVM所允许的深度异常抛出StackOverflowError</li>
<li>允许动态扩展,若无法申请到足够内存异常抛出OutOfMemoryError</li>
</ul>
</li>
</ul>
</li>
<li>程序计数器<ul>
<li>指向虚拟机字节码指令的区域</li>
<li>唯一一个不会有OOM的区域</li>
</ul>
</li>
</ul>
</li>
<li>线程共享区域<ul>
<li>堆 (类实例区)<ul>
<li>新生代</li>
<li>老年代</li>
<li>异常—-OutOfMemoryError</li>
</ul>
</li>
<li>静态方法区</li>
</ul>
</li>
<li>直接内存<ul>
<li>不受jvm gc管理</li>
</ul>
</li>
</ul>
<img src="/2019/10/java/jvm/memory.png" class="">

<hr>
<h3 id="运行时内存"><a href="#运行时内存" class="headerlink" title="运行时内存"></a>运行时内存</h3><p>区域划分大致如下:</p>
<img src="/2019/10/java/jvm/heap-1.png" class="">


<h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><ul>
<li>Eden<ul>
<li>Java新对象的出生地.当Eden区内存不够的时候就会触发MinorGC,对新生代区进行一次垃圾回收<ul>
<li>如果新创建的对象占用内存很大,则直接分配到老年代</li>
</ul>
</li>
</ul>
</li>
<li>ServivorFrom<ul>
<li>上一次GC的幸存者,做为这次GC的被扫描者</li>
</ul>
</li>
<li>ServivorTo<ul>
<li>保留了一次MinorGC过程中的幸存者</li>
</ul>
</li>
<li>MinorGC 的过程（复制-&gt;清空-&gt;互换） <ul>
<li>eden、 servivorFrom 复制到 ServivorTo，年龄+1 <ul>
<li>首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年<br>龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 位置不够就放到老年区）； </li>
</ul>
</li>
<li>清空 eden、 servivorFrom <ul>
<li>然后，清空 Eden 和 ServicorFrom 中的对象； </li>
</ul>
</li>
<li>ServivorTo 和 ServivorFrom 互换 <ul>
<li>最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom<br>区。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><p>主要存放应用程序中生命周期长的内存对象.老年代的对象比较稳定，所以 MajorGC 不会频繁执行。</p>
<ul>
<li><p>在进行 MajorGC 前一般都先进行<br>了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。</p>
</li>
<li><p>当无法找到足<br>够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。</p>
</li>
<li><p>MajorGC 采用标记清除算法：</p>
<p>耗时比较长，因要扫描再回收。 会产生内存碎片，为了减<br>少内存损耗，一般需要进行合并或者标记出来方便下次直接分配。</p>
<p>当老年代也满了装不下的<br>时候，就会抛出 OOM（Out of Memory）异常。</p>
<ul>
<li>首先扫描一次所有老年代，标记出存活的对象，</li>
<li>然后回收没有标记的对象。  </li>
</ul>
</li>
</ul>
<h5 id="持久代"><a href="#持久代" class="headerlink" title="持久代"></a>持久代</h5><p>指内存的永久保存区域，</p>
<ul>
<li><p>主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被<br>放入永久区域，</p>
</li>
<li><p>它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。</p>
</li>
<li><p>永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常 </p>
</li>
<li><p>JAVA8 与元数据</p>
<blockquote>
<p>  在 Java8 中， 永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。</p>
<p>  元空间<br>  的本质和永久代类似，元空间与永久代之间最大的区别在于： </p>
<blockquote>
<p>  元空间并不在虚拟机中，而是使用<br>  本地内存。默认情况下，元空间的大小仅受本地内存限制。 类的元数据放入 native<br>  memory, 字符串池和类的静态变量放入 java 堆中， 这样可以加载多少类的元数据就不再由<br>  MaxPermSize 控制, 而由系统的实际可用空间来控制。 </p>
</blockquote>
</blockquote>
</li>
</ul>
<hr>
<h3 id="垃圾回收与算法"><a href="#垃圾回收与算法" class="headerlink" title="垃圾回收与算法"></a>垃圾回收与算法</h3><ul>
<li>哪些内存需要回收?<ul>
<li>heap堆内存的回收</li>
</ul>
</li>
<li>什么时候需要回收?<ul>
<li>当新生代中Eden内存不足时,会触发MinorGC</li>
<li>当新生代中有对象晋升入老年代,空间不足时会触发MajorGC</li>
</ul>
</li>
<li>采用什么方式回收?<ul>
<li>通过引用记数法和可达性分析来确定哪些是需要回收的垃圾</li>
<li>通过垃圾收集器根据对应的算法来收集并回收</li>
</ul>
</li>
</ul>
<h4 id="垃圾确认"><a href="#垃圾确认" class="headerlink" title="垃圾确认"></a>垃圾确认</h4><h5 id="引用记数法"><a href="#引用记数法" class="headerlink" title="引用记数法"></a><strong>引用记数法</strong></h5><ul>
<li><p><strong>算法分析</strong></p>
<ul>
<li>引用计数是垃圾收集器中的早期策略。</li>
<li>堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。</li>
<li>当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。</li>
<li>任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</li>
</ul>
</li>
<li><p><strong>优缺点</strong></p>
<ul>
<li><strong>优点</strong>：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</li>
<li><strong>缺点</strong>：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。引用计数永远不可能为0。</li>
</ul>
<h4 id="是不是很无趣，来段代码压压惊"><a href="#是不是很无趣，来段代码压压惊" class="headerlink" title="是不是很无趣，来段代码压压惊"></a>是不是很无趣，来段代码压压惊</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceFindTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyObject object1 = new MyObject();</span><br><span class="line">        MyObject object2 = new MyObject();</span><br><span class="line">          </span><br><span class="line">        object1.object = object2;</span><br><span class="line">        object2.object = object1;</span><br><span class="line">          </span><br><span class="line">        object1 = null;</span><br><span class="line">        object2 = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这段代码是用来验证引用计数算法不能检测出循环引用。最后面两句将<code>object1</code>和<code>object2</code>赋值为<code>null</code>，也就是说<code>object1</code>和<code>object2</code>指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。</p>
</li>
</ul>
<h5 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h5><ul>
<li>通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到 GC Roots 没有任何的引用链相连时(从 GC Roots 到这个对象不可达)时，证明此对象不可用</li>
<li>GC Roots的对象<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象。(可以理解为:引用栈帧中的本地变量表的所有对象)</li>
<li>方法区中静态属性引用的对象(可以理解为:引用方法区该静态属性的所有对象)</li>
<li>方法区中常量引用的对象(可以理解为:引用方法区中常量的所有对象)</li>
<li>本地方法栈中(Native方法)引用的对象(可以理解为:引用Native方法的所有对象)</li>
</ul>
</li>
</ul>
<img src="/2019/10/java/jvm/Roots.png" class="">
<p>  </p>
<h5 id="最终判定"><a href="#最终判定" class="headerlink" title="最终判定"></a><strong>最终判定</strong></h5><p>   即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p>
<p>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。</p>
<ul>
<li><p>第一次标记</p>
<ul>
<li>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记。</li>
</ul>
</li>
<li><p>第二次标记</p>
<ul>
<li>第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。在<code>finalize()</code>方法中没有重新与引用链建立关联关系的，将被进行第二次标记。</li>
</ul>
</li>
</ul>
<p>Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己—-只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</p>
<p><strong>方法区如何判断是否需要回收</strong></p>
<p>  方法区存储内容是否需要回收的判断可就不一样咯。方法区主要回收的内容有：</p>
<p>​    废弃常量和无用的类。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li>
<li>加载该类的<code>ClassLoader</code>已经被回收；</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>流程图如下：  </p>
<img src="/2019/10/java/jvm/gcRoots.png" class="">

<h4 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h4><h5 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h5><img src="/2019/10/java/jvm/serialGC.png" class="">

<ul>
<li><p>串行收集器组合 Serial + Serial Old </p>
<blockquote>
<p>   开启选项：-XX:+SerialGC</p>
</blockquote>
<ul>
<li>串行收集器是最基本、发展时间最长、久经考验的垃圾收集器，也是client模式下的默认收集器配置。</li>
<li>串行收集器采用单线程stop-the-world的方式进行收集。<ul>
<li>当内存不足时，串行GC设置停顿标识，待所有线程都进入安全点(Safepoint)时，应用线程暂停，串行GC开始工作，采用单线程方式回收空间并整理内存。</li>
</ul>
</li>
<li>单线程也意味着复杂度更低、占用内存更少，但同时也意味着不能有效利用多核优势。串行收集器特别适合堆内存不高、单核甚至双核CPU的场合。</li>
</ul>
</li>
</ul>
<h5 id="并行收集器"><a href="#并行收集器" class="headerlink" title="并行收集器"></a>并行收集器</h5><img src="/2019/10/java/jvm/useParallelGC.png" class="">

<ul>
<li><p>并行收集器组合 Parallel Scavenge + Parallel Old</p>
<blockquote>
<p>  开启选项：-XX:+UseParallelGC或-XX:+UseParallelOldGC(可互相激活)</p>
</blockquote>
<ul>
<li>并行收集器是以关注吞吐量为目标的垃圾收集器，也是server模式下的默认收集器配置，对吞吐量的关注主要体现在年轻代Parallel Scavenge收集器上。<ul>
<li>并行收集器与串行收集器工作模式相似，都是stop-the-world方式，只是暂停时并行地进行垃圾收集。年轻代采用复制算法，老年代采用标记-整理，在回收的同时还会对内存进行压缩。</li>
<li>关注吞吐量主要指年轻代的Parallel Scavenge收集器，通过两个目标参数-XX:MaxGCPauseMills和-XX:GCTimeRatio，调整新生代空间大小，来降低GC触发的频率。</li>
</ul>
</li>
<li>并行收集器适合对吞吐量要求远远高于延迟要求的场景，并且在满足最差延时的情况下，并行收集器将提供最佳的吞吐量。</li>
</ul>
</li>
</ul>
<h5 id="并发标记清除收集器"><a href="#并发标记清除收集器" class="headerlink" title="并发标记清除收集器"></a>并发标记清除收集器</h5><img src="/2019/10/java/jvm/useConcMarkSweepGC.png" class="">

<ul>
<li><p>并发标记清除收集器组合 ParNew + CMS + Serial Old</p>
<blockquote>
<p>  开启选项：-XX:+UseConcMarkSweepGC</p>
</blockquote>
<ul>
<li>并发标记清除(CMS)是以关注延迟为目标、十分优秀的垃圾回收算法，开启后，年轻代使用STW式的并行收集，老年代回收采用CMS进行垃圾回收，对延迟的关注也主要体现在老年代CMS上。<ul>
<li>年轻代ParNew与并行收集器类似，而老年代CMS每个收集周期都要经历：<ul>
<li>初始标记：以STW的方式标记所有的根对象,多线程执行；</li>
<li>并发标记：同应用线程一起并行，标记出根对象的可达路径；</li>
<li>重新标记：在进行垃圾回收前，CMS再以一个STW进行重新标记，标记那些由mutator线程(指引起数据变化的线程，即应用线程)修改而可能错过的可达对象；</li>
<li>进行回收：最后得到的不可达对象将在并发清除阶段进行回收。</li>
</ul>
</li>
</ul>
</li>
<li>CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。</li>
<li>缺点：<ul>
<li>由于并发进行，CMS在收集与应用线程会同时增加对堆内存的占用，<ul>
<li>CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间；</li>
<li>标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。</li>
</ul>
</li>
<li>CMS也提供了参数-XX:CMSFullGCsBeForeCompaction(默认0，即每次都进行内存整理)来指定多少次CMS收集之后，进行一次压缩的Full GC。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>上面的垃圾收集器组合，都有几个共同点：</p>
<ul>
<li><p>年轻代、老年代是独立且连续的内存块；</p>
</li>
<li><p>年轻代收集使用单eden、双survivor进行复制算法；</p>
</li>
<li><p>老年代收集必须扫描整个老年代区域；</p>
</li>
<li><p>都是以尽可能少而块地执行GC为设计原则。</p>
</li>
</ul>
<h5 id="Garbage-First-G1-收集器"><a href="#Garbage-First-G1-收集器" class="headerlink" title="Garbage First (G1)收集器"></a>Garbage First (G1)收集器</h5><img src="/2019/10/java/jvm/useG1GC.png" class="">

<blockquote>
<p>  开启选项：-XX:+UseG1GC</p>
</blockquote>
<p>G1垃圾收集器以关注延迟为目标、服务器端应用的垃圾收集器，虽然G1也有类似CMS的收集动作：</p>
<p>初始标记、并发标记、重新标记、清除、转移回收，并且也以一个串行收集器做担保机制，但单纯地以类似前三种的过程描述显得并不是很妥当。事实上，G1收集与以上三组收集器有很大不同：</p>
<ul>
<li><p>G1的设计原则是”首先收集尽可能多的垃圾(Garbage First)”。</p>
<ul>
<li>G1并不会等内存耗尽(串行、并行)或者快耗尽(CMS)的时候开始垃圾收集，而是在内部采用了启发式算法，在老年代找出具有高收集收益的分区进行收集。</li>
<li>G1可以根据用户设置的暂停时间目标自动调整年轻代和总堆大小，暂停目标越短年轻代空间越小、总空间就越大；</li>
</ul>
</li>
<li><p>G1采用内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中。</p>
<ul>
<li>由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)；</li>
</ul>
</li>
<li><p>G1也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。</p>
<ul>
<li>G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换；</li>
</ul>
</li>
<li><p>G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式。</p>
<ul>
<li>即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿。</li>
</ul>
</li>
</ul>
<p><strong>G1的内存模型</strong></p>
<p>分区概念</p>
<img src="/2019/10/java/jvm/G1Region.png" class="">


<ul>
<li>G1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。</li>
<li>在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；</li>
<li>每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。</li>
<li>启动时可以通过参数<code>-XX:G1HeapRegionSize=n</code>可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。</li>
</ul>
<blockquote>
<p>  G1是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。</p>
<p>  通过主要的参数初始和最大堆空间、以及最大容忍的GC暂停目标，就能得到不错的性能；</p>
<p>  G1对内存空间的浪费较高，但通过<strong>首先收集尽可能多的垃圾(Garbage First)</strong>的设计原则，可以及时发现过期对象，从而让内存占用处于合理的水平。</p>
</blockquote>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><ul>
<li><h5 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h5><p>采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收</p>
<p>标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p>
</li>
</ul>
<img src="/2019/10/java/jvm/concMarkSweep.png" class="">

<h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>  复制算法的提出是为了克服句柄的开销和解决内存碎片的问题。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集合（GC Roots）中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。</p>
<img src="/2019/10/java/jvm/copy.png" class="">

<h5 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h5><p>  标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。</p>
<p>标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。具体流程见下图：</p>
<img src="/2019/10/java/jvm/Mark-Compact.jpg" class="">

<h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><p>  分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p>
<img src="/2019/10/java/jvm/generational-collection.png" class="">

<ul>
<li><p><strong>年轻代（Young Generation）的回收算法</strong></p>
<ul>
<li>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</li>
<li>新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)<ul>
<li>大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</li>
</ul>
</li>
<li>当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。</li>
<li>新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。</li>
</ul>
</li>
<li><p><strong>年老代（Old Generation）的回收算法</strong></p>
<ul>
<li>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。可以认为年老代中存放的都是一些生命周期较长的对象。</li>
<li>内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</li>
</ul>
</li>
<li><p><strong>持久代（Permanent Generation）的回收算法</strong></p>
</li>
</ul>
<p>  用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代也称方法区</p>
<h4 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h4><p>下面一张图是HotSpot虚拟机包含的所有收集器，图是借用过来滴：</p>
<img src="/2019/10/java/jvm/HotSpot-collection.png" class="">

<ul>
<li>Serial收集器（复制算法)<br>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是client级别默认的GC方式，可以通过<code>-XX:+UseSerialGC</code>来强制指定。</li>
<li>Serial Old收集器(标记-整理算法)<br>老年代单线程收集器，Serial收集器的老年代版本。</li>
<li>ParNew收集器(停止-复制算法)　<br>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</li>
<li>Parallel Scavenge收集器(停止-复制算法)<br>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。是server级别默认采用的GC方式，可用<code>-XX:+UseParallelGC</code>来强制指定，用<code>-XX:ParallelGCThreads=4</code>来指定线程数。</li>
<li>Parallel Old收集器(停止-复制算法)<br>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先。</li>
<li>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）<br>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择。</li>
</ul>
<h3 id="GC是什么时候触发的"><a href="#GC是什么时候触发的" class="headerlink" title="GC是什么时候触发的"></a>GC是什么时候触发的</h3><p>  由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p>
<h4 id="Scavenge-GC"><a href="#Scavenge-GC" class="headerlink" title="Scavenge GC"></a>Scavenge GC</h4><p>  一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p>
<h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>  对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：</p>
<ul>
<li><p>年老代（Tenured）被写满；</p>
</li>
<li><p>持久代（Perm）被写满；</p>
</li>
<li><p>System.gc()被显示调用；</p>
</li>
<li><p>上一次GC之后Heap的各域分配策略动态变化；</p>
</li>
</ul>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>  无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在Java语言中，将引用又分为强引用、软引用、弱引用、虚引用4种，这四种引用强度依次逐渐减弱。</p>
<ul>
<li>强引用</li>
</ul>
<p>  在程序代码中普遍存在的，类似 <code>Object obj = new Object()</code> 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。引用计数算法还是可达性分析算法都是基于强引用而言的。</p>
<ul>
<li>软引用</li>
</ul>
<p>  用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p>
<ul>
<li>弱引用</li>
</ul>
<p>  也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>
<ul>
<li>虚引用</li>
</ul>
<p>  也叫幽灵引用或幻影引用（名字真会取，很魔幻的样子），是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="zkzlx"
    src="/images/custom-logo.jpg">
  <p class="site-author-name" itemprop="name">zkzlx</p>
  <div class="site-description" itemprop="description">吃饭、睡觉、写代码、周而复始</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/alibaba/spring-cloud-alibaba" title="GitHub &amp;rarr; https:&#x2F;&#x2F;github.com&#x2F;alibaba&#x2F;spring-cloud-alibaba" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://mercyblitz.github.io/" title="https:&#x2F;&#x2F;mercyblitz.github.io" rel="noopener" target="_blank">小马哥(mercyblitz)</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://fangjian0423.github.io/" title="https:&#x2F;&#x2F;fangjian0423.github.io" rel="noopener" target="_blank">洛夜(fangjian0423)</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://zkzlx.github.io/" title="https:&#x2F;&#x2F;zkzlx.github.io">冰封(zkzlx)</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zkzlx</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.4.2
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

</body>
</html>
